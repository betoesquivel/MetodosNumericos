{"ts":1362809233269,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#include <iostream>\nusing namespace std; \nstring tag = \"DEBUG::\";\nconst int size = 11; \nclass Montante{\n\tprivate: \n\t\tdouble matriz[size][size];//11 es el número máximo de ecuaciones aceptadas y 10 es el número máximo de variables aceptadas. \n\t\tint filas; \n\t\tint columnas;\n\t\tdouble soluciones[size]; \n\t\t\n\t\t //tag de los mensajes\n\t\tbool debug; //si este boolean es verdadero, se desplieagan mensajes con el procedimiento\n\t\tbool sinSoluciones; //si al final de montante, quedan ecuaciones con soluciones distintas\n\t\tbool solucionesInfinitas; //si al final de montante, quedan ecuaciones que den la misma solución \n\t\t\n\n\t\tdouble pivAnterior; \n\t\tdouble pivActual; //el valor en la posición kk de la matriz\n\t\tint k; //el índice que se utilizará para moverse por la diagonal principal\n\t\n\tpublic:\n\t\tMontante(double m[size][size], int f, int c);\n\t\tMontante(double m[size][size], int f, int c, bool);//se inicializa en bool el valor de debug para mostrar el proceso\n\t\t\n\t\tvoid MetodoPrincipal();//ciclo principal de montante\n\t\t\n\t\tvoid conversionACeros();//convierte a 0s todo antes del índice en donde esté menos la diagonal principal\n\t\tvoid operacionesEnPrimerCuadrante();//realiza las operaciones del primer cuadrante\n\t\tvoid operacionesEnSegundoCuadrante();//realiza las operaciones del cuarto cuadrante\n\t\tvoid cambiarRenglones(int fila1, int fila2);//cambia los renglones\n\t\t\n\t\t\n\t\tvoid calcularSolucion(); //en el caso de que se esté usando un sistema de ecuaciones lineales con montante\n\t\tvoid calcularInversa(); //en el caso de que se haya usado montante para calcular la inversa de una matriz\n\t\t\n\t\tbool getSinSoluciones();\n\t\tbool getSolucionesInfinitas();\n\t\tvoid imprimirSoluciones();\n\t\t\n\t\tvoid imprimirMatriz();\n};\n\n\t\tMontante::Montante(double m[size][size], int f, int c){\n\t\t\tfor(int fila = 0; fila<f; fila++){\n\t\t\t\tfor(int columna = 0; columna<c; columna++)\n\t\t\t\t\tmatriz[f][c] = m[f][c];\n\t\t\t}\n\t\t\t\n\t\t\tfilas = f;\n\t\t\tcolumnas = c;\n\t\t\tk = 0; \n\t\t\tpivAnterior = 1; \n\t\t\tsinSoluciones = false; \n\t\t\tsolucionesInfinitas = false; \n\t\t}\n\t\tMontante::Montante(double m[size][size], int f, int c, bool deb){//se inicializa en bool el valor de debug para mostrar el proceso\n\t\t\tfilas = f;\n\t\t\tcolumnas = c;\n\t\t\tdebug = true; \n\t\t\tk = 0; \n\t\t\tpivAnterior = 1; \n\t\t\tsinSoluciones = false; \n\t\t\tsolucionesInfinitas = false; \n\t\t\t\n\t\t\tfor(int fila = 0; fila<f; fila++){\n\t\t\t\tfor(int columna = 0; columna<c; columna++){\n\t\t\t\t\tmatriz[f][c] = m[f][c];\n\t\t\t\t\tif(debug){\n\t\t\t\t\t\tcout<<tag<<\"Copiando\"<<endl; \n\t\t\t\t\t\tcout<<m[f][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tbool Montante::getSinSoluciones(){\n\t\t\treturn sinSoluciones;\n\t\t}\n\t\tbool Montante::getSolucionesInfinitas(){\n\t\t\treturn solucionesInfinitas;\n\t\t}\n\t\tvoid Montante::imprimirSoluciones(){\n\t\t\tfor(int i = 0; i<filas; i++){\n\t\t\t\tcout<<\"Solucion \"<<i+1<<\": \"<<soluciones[i]<<endl;\t\n\t\t\t}\t\n\t\t}\n\t\t//ciclo principal de montante\n\t\tvoid Montante::MetodoPrincipal(){\n\t\t\twhile(!sinSoluciones && !solucionesInfinitas && k<filas){\n\t\t\t\tpivActual = matriz[k][k];\n\t\t\t\tconversionACeros();\n\t\t\t\toperacionesEnPrimerCuadrante();\n\t\t\t\toperacionesEnSegundoCuadrante();\n\t\t\t\t\n\t\t\t\t//esojo la siguiente fila y cambio la k; \n\t\t\t\tpivAnterior = pivActual; \n\t\t\t\tk++;\n\t\t\t\tint sigFila = k; \n\t\t\t\twhile(matriz[sigFila][k]==0 && sigFila<filas){\n\t\t\t\t\tsigFila++;\n\t\t\t\t}\n\t\t\t\tif(matriz[sigFila][k]==0){\n\t\t\t\t\t//sin solución o soluciones infinitas\t\n\t\t\t\t}else{\n\t\t\t\t\t//cambio el renglón k, por el renglón sigFila en la matriz\t\n\t\t\t\t\tcambiarRenglones(sigFila, k); \n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t//convierte a 0s todo antes del índice en donde esté menos la diagonal principal\n\t\tvoid Montante::conversionACeros(){\n\t\t\tfor(int f = 0; f<filas; f++){\n\t\t\t\tfor(int c = 0; c<=k; c++){\n\t\t\t\t\tif(f!=c)\n\t\t\t\t\t\tmatriz[f][c] = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tmatriz[f][c] = pivActual;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(debug){\n\t\t\t\tcout<<tag<<\"Conversión a Ceros\"<<endl;\n\t\t\t\timprimirMatriz();\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid Montante::operacionesEnPrimerCuadrante(){\n\t\t\t//uso la matriz, el índice en el que me encuentro k, y el pivote actual y anterior\n\t\t\tfor(int f = 0; f<k; f++){\n\t\t\t\tfor(int c = k+1; c<columnas; c++){\n\t\t\t\t\tmatriz[f][c] = (-1)*( matriz[f][k]*matriz[k][c] - matriz[f][c]*pivActual ) / pivAnterior;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(debug){\n\t\t\t\tcout<<tag<<\"Operaciones Primer Cuadrante\"<<endl;\n\t\t\t\timprimirMatriz();\n\t\t\t}\n\t\t}\n\t\tvoid Montante::operacionesEnSegundoCuadrante(){\n\t\t\tfor(int f = k+1; f<filas; f++){\n\t\t\t\tfor(int c = k+1; c<columnas; c++){\n\t\t\t\t\tmatriz[f][c] = ( pivActual*matriz[f][c] - matriz[k][c]*matriz[f][k] ) / pivAnterior;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tif(debug){\n\t\t\t\tcout<<tag<<\"Operaciones Segundo Cuadrante\"<<endl;\n\t\t\t\timprimirMatriz();\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tvoid Montante::cambiarRenglones(int fila1, int fila2){\n\t\t\tdouble temp;\n\t\t\tfor(int c = 0; c<columnas; c++){\n\t\t\t\ttemp = matriz[fila2][c];\n\t\t\t\tmatriz[fila2][c] = matriz[fila1][c];\n\t\t\t\tmatriz[fila1][c] = temp;\n\t\t\t}\n\t\t\tif(debug){\n\t\t\t\tcout<<tag<<\"Cambiar renglones\"<<endl;\n\t\t\t\timprimirMatriz();\n\t\t\t}\t\t\t\n\t\t}\n\t\t //en el caso de que se esté usando un sistema de ecuaciones lineales con montante\n\t\tvoid Montante::calcularSolucion(){\n\t\t\tdouble determinante = matriz[0][0];\n\t\t\tfor(int f = 0; f<filas; f++){\n\t\t\t\tsoluciones[f] = matriz[f][columnas-1]/determinante;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//en el caso de que se haya usado montante para calcular la inversa de una matriz\n\n\t\tvoid Montante::calcularInversa(){\n\t\t\t//luego lo hago\n\t\t}\t\t\n\t\tvoid Montante::imprimirMatriz(){\n\t\t\tfor(int f = 0; f<filas; f++){\n\t\t\t\tfor(int c = 0; c<columnas;  c++){\n\t\t\t\t\tcout<<matriz[f][c]<<\" \";\n\t\t\t\t}\n\t\t\t\tcout<<endl; \n\t\t\t}\n\t\t\tcout<<endl; \n\t\t}\n\n\n\nint main(){\n\tdouble matrizExtendida[size][size];\n\tint casos, variables, numEcuaciones; \n\tcin>>casos; \n\twhile(casos>0){\n\t\n\t\tcout<<\"Variables: \"<<endl; \n\t\tcin>>variables;\n\t\tcout<<\"Ecuaciones: \"<<endl;\n\t\tcin>>numEcuaciones; \n\t\t\n\t\tdouble temp; \n\t\t//llenar la matriz extendida fila por fila\n\t\tfor(int f = 0; f<numEcuaciones; f++){\n\t\t\t\n\t\t\tfor(int c = 0; c<variables+1;  c++){\n\t\t\t\tcin>>temp;\n\t\t\t\tcout<<\"Solo probando\"<<temp<<endl; \n\t\t\t\tmatrizExtendida[f][c] = temp;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tMontante miMontante(matrizExtendida, numEcuaciones, variables+1, true);\n\t\tmiMontante.MetodoPrincipal();\n\t\t//Imprimir la respuesta. \n\t\tif(miMontante.getSinSoluciones()){\n\t\t\tcout<<\"Sin solución\";\n\t\t}else{\n\t\t\tif(miMontante.getSolucionesInfinitas()){\n\t\t\t\tcout<<\"Soluciones infinitas\";\n\t\t\t}else{\n\t\t\t\tmiMontante.calcularSolucion();\n\t\t\t\tmiMontante.imprimirSoluciones();\n\t\t\t}\n\t\t}\n\t\tcout<<endl; \n\t\tcasos--; \n\t\t\n\t}\n\t\n\t\n\treturn 0; \n}\n"]],"start1":0,"start2":0,"length1":0,"length2":6352}]],"length":6352}
